# AQA CS A-Level Notes

# 4.4 Theory of Computation

**[Bourne to Code Link](https://bournetocode.com/projects/AQA_A_Theory/pages/4-4.html)**

# 4.4.1 Abstraction and Automation
## 1. Problem-Solving
## 2. Following and Writing Algorithms
**Algorithms**
+ A finite steps of instructions/steps to solve a specific problem, algorithms can be expressed in the following forms:
  + Flowchart
  + Pseudo-Code
  + Structured English
+ Algorithms employ with the standard constructs:
  + Sequence
  + Assignment
  + Selection
  + Iteration
+ **Dry Run** an algorithm means the programmer working through a program on paper, using a table called a **Trace Table**
+ To test a solution, there needs to be a set of test data that will thoroughly test the solution:
  + **Typical Data**: the solution expected data including type and range
  + **Extreme Data**: Data that is on the extreme limits of the range but should be accepted
    + E.g. If the validation says that price <= £100 then £100 should be tested as that is right at the upper limit
  + **Erroneous/Invalid data**: the solution should output error for those data; either because of wrong type or exceeding the limits
  
## 3. Abstraction
+ Abstraction can be achieved by:
  + Representational abstraction: A representation arrived at by removing unnecessary details
  + Abstraction by generalisation or categorisation: a grouping by common characteristics to arrive at a hierarchial relationship of the "is a kind of" type
+ **Procedural Abstraction**:
  + Disregards the actual values, the result of a procedural abstraction is a procedure/computational method, not a function
  + To get a function requires yet another abstraction, which disregards computation method. This is **Functional Abstraction**
+ **Data Abstraction**:
  + Details of how data are actually represented are hidden, allowing new kinds of data objects to be constructed from previously defined types of data
  + E.g. a stack could be implemented as an array and a pointer for the top of a stack. A tree can be implemented as three arrays with one for the left pointer, one for the right pointer and one for the nodes' values

## 4. Information Hiding
## 5. Procedural Abstraction
## 6. Functional Abstraction
## 7. Data Abstraction
## 8. Problem Abstraction/Reduction
## 9. Decomposition
## 10. Composition
## 11. Automation

# 4.4.2 Regular Languages
## 1. Finite State Machines With and Without Output
## 2. Maths for Regular Expressions
## 3. Regular Expressions
## 4. Regular Language

# 4.4.3 Context-Free Languages
## 1. Backus-Naur Form (BNF)/Syntax Diagrams

# 4.4.4 Classification of Algorithms
## 1. Comparing Algorithms
## 2. Maths for Understanding Big-O Notation
## 3. Order of Complexity
## 4. Limits of Computation
## 5. Classification of Algorithmic Problems
## 6. Computable and Non-Computable Problems
## 7. Halting Problem

# 4.4.5 A Model of Computation
## 1. Turing Machine
