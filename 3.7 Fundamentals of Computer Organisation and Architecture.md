#AQA CS AS Notes

##3.7 Fundamentals of Computer Organisation and Architecture

**[Bourne to Code Link](https://bournetocode.com/projects/AQA_AS_Theory/pages/3-7.html)**

##Internal Hardware Components of a Computer
**Internal Components**
+ These include **CPU**, **components within a CPU**, **main memory**, **buses** and **I/O controllers**.
+ This diagram shows how different components in a computer work together as a functional system:
![diagram](https://bournetocode.com/projects/AQA_AS_Theory/pages/img/Computer-Components.png)

##Processor, ALU, Control Unit, Registers, Memory
+ **Processor**
  + Made up of the **control unit**, the **ALU** and several *registers*
+ **The Control Unit**
  + Controls and coordinates all operations
  + It works through a **fetch**, **decode** and **execution** cycle
    + The **fetch** operation fetches the next instruction from the main memory
    + The **decode** operation outputs what the **ALU** needs to perform on the data
    + The **execution** operation causes the instruction to be carried out
  + The **control unit's** role can be summarised as:
    + To **fetch**/**decode**/**execute** instructions
    + To synchronise the operation of the processor
    + To control the operation of the **fetch-execute cycle**
    + To send commands to the other components of the **fetch-execute cycle**
+ **Registers**
  + Registers are small but very fast to hold data before and after being processed by the CPU
  + All **ALU** operartions are accomplished within registers
+ **Arithmetic Logic Unit (ALU)**
  + The **ALU** performs addition, subtraction, multiplication, division, comparison and bitwise operations
+ **Memory**
  + Memory is used to hold temporary instructions and data, for manipulation, while the system is running
  + When a block of code or data is held in memory, it's directly accessible by the CPU for manipulation
  + Memory is organised in units called **words**
    + A **word** is the maximum number of bits a CPU can process in a single instruction.
    + The typical **word size** is 8, 16, 32 or 64 bits
    + Each **word** has its own address in the memory

##Structure and Role of the Processor and its Components
####The Processor and its Components
**The Role and Operation of a Processor and its Major Components**
+ **Arithemtic Logic Unit**: A circuit inside a CPU performs the following functions:
  + ADD, SUBTRACT, MULTIPLY, DIVIDE
  + Arithmetic (signed bit patterns) and logic shift (unsigned bit patterns) on instructions within a register
  + Performs logical operations such as AND, XOR, OR, NOT
+ **Control Unit**:
  + It **controls and coordinates the activities within the CPU** and **controls the flow of data in and out of CPU**
  + It **takes and instruction and decodes it into opcode and operands**
  + It **manages the execution of the decode instructions**. **fetches data from location** and **stores the results in memory or registers**
+ **Clock**:
  + The syetem clock is used to **synchronise CPU operations**
  + It **generates a series of signals of alternating 0s and 1s**
  + The **CPU takes at least once cycle of time (from 0 to 1 or from 1 to 0) to perform one instruction**
+ **General-Purpose Registers**:
  + **Registers** are very fast and small memory inside the CPU to hold data before, during and after being processed by the CPU
  + Typically, a CPU can have up to 16 registers
  + Some CPUs only have one general purpose register, called an **accumulator**
+ **Dedicated Registers**:
  + **Program Counter (PC)**: A special purpose register that holds the address of the next instruction
  + **Current Instruction Register (CIR or IR)**: Holds the currently being executed instruction
  + **Memory Address Register (MAR)**: Holds the memory address of an instruction to be fetched or written to
  + **Memory Buffer Register (MBR)**: A.K.A. Memory Data Register (MDR), holds the data fetched from or written to memory
  + **Status Register (SR)**: Holds the bits to indicate the results of the execution of an instruction. such as overflow, negative, zero or carry over
+ A diagram look at a processor:
<img src = "processor.jpg">

##The Fetch-Execute Cycle and the Role of Registers Within it 
+ When an instruction of a program is being processed by the CPU, it goes through this cycle:
  + **Fetching**
    + Retrieves a program instruction from its memory
  + **Decoding**
    + Determines what actions the instruction requires
  + **Executing**
    + Carries out the decoded actions
+ **Registers' Roles** in the fetch-decode-execute cycle are illustrated in the flowchart:

<img src = "Fetch-Execute Cycle.png" width = "200">

+ **Fetch**:
  + Contents of the PC transferred to **MAR**
  + Address bus used to transfer this address to main memory
  + Contents of addressed memory location moved into the **MBR** by the data bus increment PC
+ **Decode**:
  + Decode instruction held by the CIR by the control unit
  + Instruction split into opcode and operand
+ **Execute**:
  + Data is fetched (if it's necessary)
  + The opcode identifies the instruction to execute
  + Execute instruction by the relevant part of the processor
  + Result is stored in the accumulator

##The Stored Program Concept
+**The Stored Program Concept** has the following properties:
  + A machine has the instructions and data being held in the same memory
  + Machine code instructions stored in main memory are fetched, decoded and executed by a processor one at a time

**The Processor Instruction Set**
+ **Processor Instruction Set** means **all the instructions supported by its hardware**
+ Different processors have different instructions sets (**instruction sets are processor specific**)
+ A typical instruction set includes the following common operations:
  + **Data handling and memory operations** - LOAD, STORE
  + **Arithmetic operations** - ADD, SUBTRACT, DIVIDE, MULTIPLY etc.
  + **Comparison operations** - >, <, = etc.
  + **Logical operations** - AND, OR, XOR, NOR, NOT etc.
  + **Control flow operations** - conditional or unconditional
  + **Logical shifts**
  + **Halt**
+ **Instructions consist of an opcode and one or more operands** (value, memory address or register)
  + Machine instruction is made of two parts:
    + **opcode**: the operation to be performed, and a 2-bit code indicate **addressing mode** used for the operation
    + **operands**: the value, memory address or register to be operated on

##Addressing Modes
+ **Immediate Addressing**:
  + The **operand is the actual value** to be operated on
+ **Direct Addressing**:
  + The **operand holds the memory address of the value** to be operated on
```
Suppose that the opcode 010 means LOAD and the addressing mode 1 indicates direct addressing.
Describe the operation that will be performed by the following machine code instruction:
0101 1100

The above instruction means: LOAD the value from the memory location at 12, because: 
      010 -------------------->  1 --------------------> 1100
The opcode for LOAD     The addressing mode     The memory location
```

##Machine Code / Assembly Language Operations
+ **First Generation Languages**:
  + Example: Machine Code
  + **Machine dependent and made of 0s and 1s**
  + Machine code is **very difficult to read and debug**
+ **Second Generation Languages**:
  + Examples: Assembly Code / Assembly Language
  + **Machine Dependent**
  + Assembly code **uses mnemonics** (aimed to helping you remember) to represent the operation codes and addresses
  + **Assembler translates assembly code into machine code**
  + **mnemonics examples**: LDR, STR, ADD, SUB, MOV, CMP
+ **Third Generation Languages**:
  + Examples: High level programming languages like Python, Java, C Family etc.
  + They **have a high level of seperation from the hardware** (less dependent on the types of hardware)
  + They are **easier for programmers to solve problems and debug**
  + They are **closer to human langauge**

**Assembly Language Operations**
+ Examples of using assembly code:#
  + 1 - Add 12 to the number stored in memory location 52 and save the result in memory location 53:
  ```
  LDR R0, 52          | load the contents of location 52 into register 0
  ADD R1, R0, #12     | add 12 to register 0 and store result in register 1
  STR R0, 53          | store the result in memory location 53
  ```
  + 2 - Brancing operation 1:
  ```
  CMP R1, 40   | Compare value in memory location 40 with value in R1
  BGT .next    | if R1 value is greater, go to label .next 

.next   HALT   | label .next which just halts
  ```
  + 3 - Branching operation 2:
  ```
  CMP R1, #100   | Compare number 100 with value in R1
  BNE .loop1     | if they are not equal, go to label .loop1
  ```
  + 4 - Write assembly code for pseudo-code:
  ```
  pseudo-code:
    X <—- 0
    repeat
     X<—-X + 1
    until X = 99

    CMP R1, #100   | Compare number 100 with value in R1
    BNE .loop1     | if they are not equal, go to label .loop1
  ```

##Factors Affecting Processor Performance
+ **Multiple Cores**:
  + Multiple processors **can carry out tasks in parallel**
  + A task can also **split up to be run on different cores in parallel to speed up execution**
+ **Cache Memory**:
  + These are **small but very fast memory which are located close to the CPU**. 
  + Next instructions or data are stored to be quickly used by the CPU to speed up the executuion
  + Depending on how close those cache memories to the CPU, they can be classified as level 1, 2, 3 etc.
+ **Clock Speed**
  + By increasing the clock speed the processor will **execute more intructions per unit of time**
+ **Word Length**:
  + The larger the word length, **the more data the CPU can process**
  + By increasing the word length, the processor **can access a larger amount of memory through direct addressing**
  + By increasing the word length, the processor could **have a larger instruction set**
+ **Address Bus Width**:
  + By increasing the address bus size we can **address more unique memory locations**
  + Increasing the address bus size **increases the maximum potential memory size**
+ **Data Bus Width**:
  + By increasing the data bus size we can **move more data around per unit of time**

## Buses - Data Bus, Control bus and Address bus
*Objectives: Understand the need for, and means of, communication between components. In particular, understand the concept of a bus and how address, data and control buses are used.*

*Address bus*

*Data bus*

*Control bus*

*I/O controllers*

## The Von Neumann and Harward Architectures
*Objectives: Be able to explain the difference between von Neumann and Harvard architectures and describe where each is typically used.*

### Understand the Concept of Addressable Memory.

## The Processor and its Components

## Explain the Role and Operation of a Processor and its Major Components:

## Explain how the Fetch-Execute cycle is used to execute machine code programs, including the stages in the cycle (fetch, decode, execute) and details of registers used.
## The processor instruction set
## Understand the term ‘processor instruction set’ and know that an instruction set is processor specific.
### Know that instructions consist of an opcode and one or more operands (value, memory address or register).

## Addressing modes

## Understand and apply immediate and direct addressing modes.
## Machine-code/assembly language operations

## Understand and apply the basic machine-code operations of:
  + load
  + add
  + subtract
  + store
  + branching (conditional and unconditional)
  + compare
  + logical bitwise operators (AND, OR, NOT, XOR)
  + logical
  + shift right
  + shift left
  + halt.

Use the basic machine-code operations above when machine-code instructions are expressed in mnemonic form- assembly language, using immediate and direct addressing.
## Factors affecting  processor performance

## Explain the effect on processor performance of:
  +  multiple cores
  +  cache memory
  +  clock speed
  +  word length
  +  address bus width
  +  data bus width.

# External hardware devices

## Input and output devices


## Know the main characteristics, purposes and suitability of the devices and understand their principles of operation.
  + barcode reader
  + digital camera
  + laser printer
  + RFID

## Secondary  storage devices

## Explain the need for secondary storage within a computer system.

## Know the main characteristics, purposes, suitability and understand the principles of operation of the following devices:

  + hard disk
  + optical disk
  + solid-state disk (SSD)

    SSD = NAND flash memory + a controller that manages pages, and blocks and complexities of writing. Based on floating gate transistors that trap and store charge. A block, made up of many pages, cannot overwrite pages, page has to be erased before it can be written to but technology requires the whole block to be erased. Lower latency and faster transfer speeds than a magnetic disk drive.
## Compare the capacity and speed of access of various media and make a judgement about their suitability for different applications.
